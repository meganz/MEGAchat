#!/bin/bash

# Source this file in the current shell to setup and android cross-compile build
# environment that supports CMake and autotools

#=== User-set variables

# Path to the toolchain generated by NDK's make-standalone-toolchain.sh script
export XENV_TOOLCHAIN_PATH=/home/loki/android-dev/toolchain

# The -march value that will be passed to the compiler
if [ -z "$XENV_TARGET_ARCH" ]; then
    export XENV_TARGET_ARCH=arm
    export XENV_TARGET_SUBARCH=v7a
fi

#=== End of user-set variables

function exportTool
{
   local path="$XENV_TOOLCHAIN_PATH/bin/$XENV_TARGET_ARCH-linux-androideabi-$2"
   export $1="$path"
   if [ ! -f "$path" ]; then
      echo -e "\033[1;31mTool $1 does not exist at path '$path'\033[1;0m"
      return
   fi
}

if [ -z "$XENV_TOOLCHAIN_PATH" ]; then
  echo "XENV_TOOLCHAIN_PATH must be set in the script, aborting"
  return 1
fi
if [ -z "$XENV_TARGET_ARCH" ]; then
  echo -e "\033[0;31mXENV_TARGET_ARCH not set, compiler will use default\033[1;0m"
fi

owndir=`echo "$(cd "$(dirname "$BASH_SOURCE")"; pwd)"`
toolchainFile="$owndir/toolchain.cmake"

if [ -z "$XENV_TOOLCHAIN_TYPE" ]; then
  if [ -f "$XENV_TOOLCHAIN_PATH/bin/$XENV_TARGET_ARCH-linux-androideabi-clang" ]; then
     XENV_TOOLCHAIN_TYPE="clang"
  elif [ -f "$XENV_TOOLCHAIN_PATH/bin/$XENV_TARGET_ARCH-linux-androideabi-gcc" ]; then
     XENV_TOOLCHAIN_TYPE="gcc"
  else
     echo "Can't detect toolchain type: no compiler found at specificed XENV_TOOLCHAIN_PATH='$XENV_TOOLCHAIN_PATH'"
     return 1
  fi
  echo -e "\033[0;33mNo toolchain type specified, autodetected \"$XENV_TOOLCHAIN_TYPE\"\033[1;0m"
fi

if [[ "$XENV_TOOLCHAIN_TYPE" == "clang" ]]; then
  export XENV_CC_NAME=clang
  export XENV_CXX_NAME=clang++
else
  export XENV_CC_NAME=gcc
  export XENV_CXX_NAME=g++
fi

export XCOMPILE_PLATFORM=android
export XENV_TOOLCHAIN_BIN="$XENV_TOOLCHAIN_PATH/bin"
export XENV_SYSROOT="$XENV_TOOLCHAIN_PATH/sysroot"
export CFLAGS="--sysroot=$XENV_SYSROOT -march=$XENV_TARGET_ARCH$XENV_TARGET_SUBARCH"
export CXXFLAGS="--sysroot=$XENV_SYSROOT -march=$XENV_TARGET_ARCH$XENV_TARGET_SUBARCH"

#Seems the crosscompiler has the C++ system include paths broken, so we need to
#give them manually with -isystem. Note that this is automatically done by CMake, so
#has to be taken care of only with autotools configure scripts
#export CPPFLAGS="--sysroot=$SYSROOT -isystem /home/dbserver/android-ndk-r10d/platforms/android-14/arch-arm/usr/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -isystem /home/dbserver/android-ndk-r10d/sources/cxx-stl/gnu-libstdc++/4.8/include/backward"
#export LDFLAGS=--sysroot=$SYSROOT

exportTool CC "$XENV_CC_NAME"
exportTool CXX "$XENV_CXX_NAME"
exportTool CPP "cpp"
exportTool LD "ld"
exportTool AR "ar"
#exportTool LIBTOOL "libtool"
exportTool RANLIB "ranlib"
exportTool AS "as"
exportTool STRIP "strip"

# Convenience variables
# CMake command to configure strophe build to use the android toolchain:

# As the toolchain file is executed very early by cmake, some of the variables
# that we set in it aren't created in the cache yet. If we set them without
# the CACHE flag, they will be reset when the cache entry is created later.
# The symptoms for this  are that the first time the user cmake file is run,
# it doesn't see the variable as defined here, but if it is run a second time
# (i.e. after a modification), the variable may 'correct itself', as it
# already exists in the cache, so it's not re-created (and reset) anymore.
# So, we must create cache entries early here for all variables that normally
# are put in cache 

if [ ! -f "$toolchainFile" ]; then

echo -e "# This toolchain file is autogenerated by env-android.sh\n\
\n\
# CMAKE_SYSTEM_NAME is used only for filename stuff, android is not recognized,\n\
# so set it to Linux
set(CMAKE_SYSTEM_NAME Linux)\n\
set(ANDROID 1)\n\
set(TARGET_ARCH $XENV_TARGET_ARCH)\n\
set(CMAKE_C_COMPILER \"$CC\" CACHE PATH \"\")\n\
set(CMAKE_CXX_COMPILER \"$CXX\" CACHE PATH \"\")\n\
set(CMAKE_SYSROOT \"$XENV_SYSROOT\")\n\
set(CMAKE_FIND_ROOT_PATH \"$XENV_SYSROOT\")\n\
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n\
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\n\
set(CMAKE_INSTALL_PREFIX \"$XENV_SYSROOT/usr\" CACHE PATH \"\")\n" > "$toolchainFile"
fi

# FIXME: Cmake picks the --sysroot flag from CFLAGS/CXXFLAGS, and also adds it
# via CMAKE_SYSROOT, resulting in the flag appearing twice

export XENV_CMAKE_ARGS="-DCMAKE_TOOLCHAIN_FILE=$toolchainFile"

# Typical configure command to build dependencies:
export XENV_CONFIGURE_ARGS="--host=${XENV_TARGET_ARCH}-linux-android\
       \"--prefix=$XENV_SYSROOT/usr\" \"--with-sysroot=$XENV_SYSROOT\""

function xcmake
{
  eval cmake $XENV_CMAKE_ARGS $@
}

function xconfigure
{
  eval ./configure $XENV_CONFIGURE_ARGS $@
}

echo "============================================"
echo "Envirnoment set to use cross-compiler toolchain:"
echo "Toolchain path: $XENV_TOOLCHAIN_PATH"
echo "Toolchain type: $XENV_TOOLCHAIN_TYPE"
echo "Target cpuarch: $XENV_TARGET_ARCH"
echo "sysroot:        $XENV_SYSROOT"
echo "C Compiler:     $CC"
echo "C++ Compiler:   $CXX"
echo
echo -e "For autotools, you can use\n\
xconfigure [your-args]\n\
or\n\
\033[1;30meval\e[0m ./configure \$XENV_CONFIGURE_ARGS [your-args]\n\
This also sets up the install prefix to the SYSROOT/usr directory\n\
\n\
For CMake, you can use \n\
xcmake [your-args]\n\
or\n\
\033[1;30meval\e[0m cmake \$XENV_CMAKE_ARGS [your-args]\n\
This also sets up the CMake install prefix to the SYSROOT/usr directory\n\
\n\
After the autoconf/cmake configure step, you can do, as normal:\n\
make && make install"

