#include "MainWindow.h"
#include "ui_MainWindow.h"
#include <QInputDialog>
#include <QMessageBox>
#include <QMenu>
#include <QTMegaChatEvent.h>
#include "uiSettings.h"
#include "chatSettings.h"

using namespace mega;
using namespace megachat;

MainWindow::MainWindow(QWidget *parent, MegaLoggerApplication *logger, megachat::MegaChatApi *megaChatApi, ::mega::MegaApi *megaApi) :
    QMainWindow(0),
    ui(new Ui::MainWindow)
{
    mApp = (MegaChatApplication *) parent;
    mNContacts = 0;
    mActiveChats = 0;
    mArchivedChats = 0;
    mInactiveChats = 0;
    ui->setupUi(this);
    ui->contactList->setSelectionMode(QAbstractItemView::NoSelection);
    ui->chatList->setSelectionMode(QAbstractItemView::NoSelection);
    mMegaChatApi = megaChatApi;
    mMegaApi = megaApi;
    onlineStatus = NULL;
    mShowArchived = false;
    mLogger = logger;
    qApp->installEventFilter(this);

    megaChatListenerDelegate = new QTMegaChatListener(mMegaChatApi, this);
    mMegaChatApi->addChatListener(megaChatListenerDelegate);
#ifndef KARERE_DISABLE_WEBRTC
    megaChatCallListenerDelegate = new megachat::QTMegaChatCallListener(mMegaChatApi, this);
    mMegaChatApi->addChatCallListener(megaChatCallListenerDelegate);

    megaSchedMeetingListenerDelegate = new megachat::QTMegaChatScheduledMeetingListener(mMegaChatApi, this);
    mMegaChatApi->addSchedMeetingListener(megaSchedMeetingListenerDelegate);
#endif
}

MainWindow::~MainWindow()
{
    removeListeners();
    delete mSettings;
    clearChatControllers();
    clearContactControllersMap();
    delete ui;
    delete mConfirmAccount;
}

void MainWindow::removeListeners()
{
    if (megaChatListenerDelegate)
    {
        mMegaChatApi->removeChatListener(megaChatListenerDelegate);
        delete megaChatListenerDelegate;
        megaChatListenerDelegate = NULL;
    }

    #ifndef KARERE_DISABLE_WEBRTC
    if (megaChatCallListenerDelegate)
    {
        mMegaChatApi->removeChatCallListener(megaChatCallListenerDelegate);
        delete megaChatCallListenerDelegate;
        megaChatCallListenerDelegate = NULL;
    }

    if(megaSchedMeetingListenerDelegate)
    {
        mMegaChatApi->removeSchedMeetingListener(megaSchedMeetingListenerDelegate);
        delete megaSchedMeetingListenerDelegate;
        megaSchedMeetingListenerDelegate = NULL;
    }
    #endif
}


void MainWindow::clearContactControllersMap()
{
    std::map<mega::MegaHandle, ContactListItemController *>::iterator it;
    for (it = mContactControllers.begin(); it != mContactControllers.end(); it++)
    {
        ContactListItemController *itemController = it->second;
        delete itemController;
    }

    mContactControllers.clear();
}

std::string MainWindow::getAuthCode()
{
    bool ok;
    QString qCode;

    while (1)
    {
        qCode = QInputDialog::getText((QWidget *)this, tr("Login verification"),
                tr("Enter the 6-digit code generated by your authenticator app"), QLineEdit::Normal, "", &ok);

        if (ok)
        {
            if (qCode.size() == 6)
            {
                return qCode.toStdString();
            }
        }
        else
        {
            return "";
        }
    }
}

void MainWindow::onTwoFactorCheck()
{
    mMegaApi->multiFactorAuthCheck(mMegaChatApi->getMyEmail());
}

void MainWindow::onTwoFactorGetCode()
{
    mMegaApi->multiFactorAuthGetCode();
}

void MainWindow::onTwoFactorDisable()
{
    std::string auxcode = getAuthCode();
    if (!auxcode.empty())
    {
        QString code(auxcode.c_str());
        mMegaApi->multiFactorAuthDisable(code.toUtf8().constData());
    }
}

void MainWindow::createFactorMenu(bool factorEnabled)
{
    QMenu menu(this);
    if(factorEnabled)
    {
        auto disableFA = menu.addAction("Disable 2FA");
        connect(disableFA, SIGNAL(triggered()), this, SLOT(onTwoFactorDisable()));
    }
    else
    {
        auto getFA = menu.addAction("Enable 2FA");
        connect(getFA, SIGNAL(triggered()), this, SLOT(onTwoFactorGetCode()));
    }

    menu.setLayoutDirection(Qt::RightToLeft);
    menu.adjustSize();
    menu.exec(ui->bSettings->mapToGlobal(
        QPoint(-menu.width()+ui->bSettings->width(), ui->bSettings->height())));

    menu.deleteLater();    
}

#ifndef KARERE_DISABLE_WEBRTC
void MainWindow::onChatCallUpdate(megachat::MegaChatApi */*api*/, megachat::MegaChatCall *call)
{
    ChatListItemController *itemController = getChatControllerById(call->getChatid());
    if (!itemController)
    {
        if (call->getStatus() > MegaChatCall::CALL_STATUS_IN_PROGRESS)
        {
            // It's a valid condition if we have been removed from the chatroom and call is being destroyed
            return;
        }

        throw std::runtime_error("Incoming call from unknown contact");
    }

#ifndef NDEBUG
    ChatWindow *window =
#endif
    itemController->showChatWindow();
    assert(window);

    if (call->hasChanged(MegaChatCall::CHANGE_TYPE_STATUS))
    {
        switch (call->getStatus())
        {
            case megachat::MegaChatCall::CALL_STATUS_INITIAL:
            {
                itemController->createMeetingView();
                if (call->isRinging() && call->getCaller() != mMegaChatApi->getMyUserHandle())
                {
                    itemController->getMeetingView()->createRingingWindow(call->getCallId());
                }

                break;
            }

            case megachat::MegaChatCall::CALL_STATUS_USER_NO_PRESENT:
            {
                assert(itemController->getMeetingView());
                itemController->getMeetingView()->setNotParticipating();
                break;
            }

            case megachat::MegaChatCall::CALL_STATUS_CONNECTING:
            {
                assert(itemController->getMeetingView());
                itemController->getMeetingView()->setConnecting();
                break;
            }
            case megachat::MegaChatCall::CALL_STATUS_WAITING_ROOM:
            case megachat::MegaChatCall::CALL_STATUS_IN_PROGRESS:
            {
                assert(itemController->getMeetingView());
                itemController->getMeetingView()->joinedToCall(*call);
                break;
            }
            case megachat::MegaChatCall::CALL_STATUS_TERMINATING_USER_PARTICIPATION:
            {
                assert(itemController->getMeetingView());
                itemController->getMeetingView()->setNotParticipating();
                // termcode is only valid at state CALL_STATUS_TERMINATING_USER_PARTICIPATION
                int termCode = call->getTermCode();

                if (termCode == megachat::MegaChatCall::TERM_CODE_CALL_DUR_LIMIT
                    || termCode == megachat::MegaChatCall::TERM_CODE_CALL_USERS_LIMIT)
                {
                    QMessageBox msgBox;
                    msgBox.setText("Please upgrade your MEGA account into a PRO plan.");
                    msgBox.setStandardButtons(QMessageBox::Ok);
                    msgBox.exec();
                }
                else if (termCode != megachat::MegaChatCall::TERM_CODE_HANGUP)
                {
                    std::string message("Termination Code: ");
                    message.append(std::to_string(termCode));
                    QMessageBox::information(this, "User terminate participation", message.c_str());
                }
                return;
            }
            case megachat::MegaChatCall::CALL_STATUS_DESTROYED:
            {
                assert(itemController->getMeetingView());
                itemController->destroyMeetingView();
                std::string message("End call reason: ");
                message.append(std::to_string(call->getEndCallReason()));
                QMessageBox::information(this, "Call destroyed", message.c_str());
                return;
            }
            default:
            {
                break;
            }
        }
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_RINGING_STATUS))
    {
        if (call->isRinging() && call->getCaller() != mMegaChatApi->getMyUserHandle())
        {
            assert(itemController->getMeetingView());
            itemController->getMeetingView()->createRingingWindow(call->getCallId());
        }
        else if (!call->isRinging())
        {
            assert(itemController->getMeetingView());
            itemController->getMeetingView()->destroyRingingWindow();
        }
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_LOCAL_AVFLAGS))
    {
        assert(itemController->getMeetingView());
        itemController->getMeetingView()->updateAudioButtonText(*call);
        itemController->getMeetingView()->updateVideoButtonText(*call);
        itemController->getMeetingView()->updateScreenButtonText(*call);
        itemController->getMeetingView()->updateLabel(call);
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_CALL_ON_HOLD))
    {
        assert(itemController->getMeetingView());
        itemController->getMeetingView()->setOnHold(call->isOnHold(), MEGACHAT_INVALID_HANDLE);
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_GENERIC_NOTIFICATION) && call->getNotificationType() == MegaChatCall::NOTIFICATION_TYPE_SFU_ERROR)
    {
        if (call->getTermCode() == megachat::MegaChatCall::TERM_CODE_PROTOCOL_VERSION)
        {
            QMessageBox msgBox;
            msgBox.setText("Please update your mega application to enjoy of latests calls features.");
            msgBox.setStandardButtons(QMessageBox::Ok);
            msgBox.exec();
        }
        std::cerr << "onChatCallUpdate: " << MegaChatCall::termcodeToString(call->getTermCode()) << ", " << call->getGenericMessage() << std::endl;
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_OUTGOING_RINGING_STOP) && !call->isOwnClientCaller())
    {
        std::cerr << "onChatCallUpdate: outgoing ringing stop received but our client is not the caller";
        return;
    }
    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_CALL_LIMITS_UPDATED))
    {
        QMessageBox msgBox;
        QString myString;
        const auto endsIn = call->getCallDurationLimit();
        msgBox.setIcon(QMessageBox::Warning);
        myString = QString("Call duration limit has changed: ")
                   + QString(std::to_string(endsIn).c_str())
                   + QString(" (seconds) due to MEGA account restrictions");

        msgBox.setText(myString);
        msgBox.setStandardButtons(QMessageBox::Ok);
        msgBox.exec();
    }
    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_CALL_WILL_END))
    {
        QMessageBox msgBox;
        QString myString;
        const auto endsAt = call->getCallWillEndTs();
        const auto current = ::mega::m_time(nullptr);
        if (endsAt < current)
        {
            assert(false);
            myString = QString("Call has already ended");
        }
        else
        {
            const auto endsIn = endsAt - current;
            myString = QString("Call will end in ")
                           + QString(std::to_string(endsIn).c_str())
                           + QString(" (seconds) due to MEGA account restrictions");
        }
        msgBox.setIcon(QMessageBox::Warning);
        msgBox.setText(myString);
        msgBox.setStandardButtons(QMessageBox::Ok);
        msgBox.exec();
    }
    if (call->hasChanged(MegaChatCall::CHANGE_TYPE_STATUS)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_LOCAL_AVFLAGS)
        || call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_OUTGOING_RINGING_STOP)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_RINGING_STATUS)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_CALL_COMPOSITION)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_CALL_ON_HOLD)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_AUDIO_LEVEL)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_NETWORK_QUALITY)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_OWN_PERMISSIONS)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_WR_ALLOW)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_WR_DENY)
        || (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_CALL_WILL_END)
                && call->getCallDurationLimit() == ::megachat::MegaChatCall::CALL_LIMIT_DISABLED))
    {
        if (itemController->getMeetingView()) { itemController->getMeetingView()->updateLabel(call); }
    }

    if (call->hasChanged(MegaChatCall::CHANGE_TYPE_CALL_SPEAK)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_SPEAK_REQUESTED)
        || call->hasChanged(MegaChatCall::CHANGE_TYPE_CALL_RAISE_HAND))
    {
        MeetingView* meetingView = itemController->getMeetingView();
        if (meetingView)
        {
            std::unique_ptr<MegaHandleList> hl (call->getSessionsClientidByUserHandle(call->getHandle()));
            assert(hl);
            for (unsigned int i = 0; i < hl->size(); ++i)
            {
                const auto cid = hl->get(i);
                MegaChatSession* sess = call->getMegaChatSession(cid);
                assert(sess);
                if (sess)
                {
                    meetingView->updateSession(*sess);
                }
            }
            itemController->getMeetingView()->updateLabel(call);
        }
    }

    if (call->hasChanged(MegaChatCall::CHANGE_TYPE_SPEAK_REQUESTED))
    {
        if (itemController->getMeetingView())
        {
            itemController->getMeetingView()->updateLabel(call);
        }
    }

    if (call->hasChanged(megachat::MegaChatCall::CHANGE_TYPE_WR_DENY))
    {
        QMessageBox msg;
        msg.setIcon(QMessageBox::Warning);
        msg.setText("A moderator has rejected to enter the call from WR");
        msg.exec();
    }
}

void MainWindow::onChatSessionUpdate(MegaChatApi *, MegaChatHandle chatid, MegaChatHandle callid, MegaChatSession *session)
{
    ChatListItemController *itemController = getChatControllerById(chatid);
    if (!itemController)
    {
        throw std::runtime_error("Session notification in a call without associated item");
    }

    MeetingView* meetingView = itemController->getMeetingView();
    assert(meetingView);
    meetingView->updateSession(*session);

    std::unique_ptr<char[]>flags(session->avFlagsToString());
    std::cerr << std::endl << "onChatSessionUpdate: " << flags.get() << std::endl;

    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_SESSION_ON_HOLD))
    {
        meetingView->setOnHold(session->isOnHold(), session->getClientid());
    }

    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_SESSION_ON_HIRES)
            && meetingView)
    {
        session->canRecvVideoHiRes()
            ? meetingView->addHiResByCid(chatid, static_cast<uint32_t>(session->getClientid()))
            : meetingView->removeHiResByCid(static_cast<uint32_t>(session->getClientid()));
    }


    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_SESSION_ON_LOWRES)
            && meetingView)
    {
        session->canRecvVideoLowRes()
            ? meetingView->addLowResByCid(chatid, static_cast<uint32_t>(session->getClientid()))
            : meetingView->removeLowResByCid(static_cast<uint32_t>(session->getClientid()));
    }

    // request automatically hi-res track, in case peer starts sending camera and screenshare simultaneously, and we only was receiving low-res track
    if (meetingView && session->isLowResCamera() && session->isHiResScreenShare())
    {
        // peer associated to this session is sending video from camera (in low-res) and video from screen share (in hi-res)
        if (!meetingView->hasHiResByCid(static_cast<uint32_t>(session->getClientid())))
        {
            std::unique_ptr<MegaChatCall> call(mMegaChatApi->getChatCallByCallId(callid));
            if (call && call->getStatus() == megachat::MegaChatCall::CALL_STATUS_IN_PROGRESS)
            {
                mMegaChatApi->requestHiResVideoWithQuality(chatid, session->getClientid(), megachat::MegaChatCall::CALL_QUALITY_HIGH_DEF);
            }
        }
    }

    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_SESSION_ON_RECORDING))
    {
        meetingView->updateSession(*session);
    }

    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_PERMISSIONS) || session->hasChanged(MegaChatSession::CHANGE_TYPE_AUDIO_LEVEL))
    {
        meetingView->updateSession(*session);
    }

    if (session->hasChanged(MegaChatSession::CHANGE_TYPE_STATUS))
    {
        if (session->getStatus() == megachat::MegaChatSession::SESSION_STATUS_IN_PROGRESS)
        {
            meetingView->addSession(*session);
            ChatListItemController* itemController = getChatControllerById(chatid);
            std::unique_ptr<MegaChatCall> call(mMegaChatApi->getChatCallByCallId(callid));
            if (call && itemController)
            {
                itemController->getMeetingView()->updateLabel(call.get());
            }
        }
        else // SESSION_STATUS_DESTROYED
        {
            meetingView->removeLowResByCid(static_cast<uint32_t>(session->getClientid()));
            meetingView->removeHiResByCid(static_cast<uint32_t>(session->getClientid()));
            meetingView->removeSession(*session);

            if ((!itemController->getItem()->isGroup() && session->getTermCode() == MegaChatSession::SESS_TERM_CODE_RECOVERABLE)
                    || (itemController->getItem()->isGroup() && !meetingView->getNumSessions()))
            {
                // if peer left a 1on1 call with a recoverable termcode, or last peer left a group call
                std::unique_ptr<MegaChatCall> call(mMegaChatApi->getChatCallByCallId(callid));
                if (call)
                {
                    meetingView->updateLabel(call.get());
                }
            }
        }
    }
}

void MainWindow::onChatSchedMeetingUpdate(MegaChatApi* /*api*/, MegaChatScheduledMeeting* /*sm*/)
{
}

void MainWindow::onSchedMeetingOccurrencesUpdate(MegaChatApi* /*api*/, MegaChatHandle /*chatid*/, bool /*append*/)
{
}

#endif

void MainWindow::closeEvent(QCloseEvent *event)
{
    event->accept();
}

MegaChatApplication* MainWindow::getApp() const
{
    return mApp;
}

void MainWindow::confirmAccount(const std::string &password)
{
    QString url = QInputDialog::getText(this, tr("Insert url confirmation"), tr("Url"));
    if (url.size())
    {
        mMegaApi->confirmAccount(url.toStdString().c_str(), password.c_str());
    }
}

void MainWindow::setEphemeralAccount(bool ephemeralAccount)
{
    mIsEphemeraAccount = ephemeralAccount;
}

ChatWindow *MainWindow::getChatWindowIfExists(MegaChatHandle chatId)
{
    ChatWindow *window = nullptr;
    ChatListItemController *itemController = getChatControllerById(chatId);
    if (itemController)
    {
        window = itemController->getChatWindow();
    }
    return window;
}

void MainWindow::clearQtContactWidgetList()
{
    ui->contactList->clear();
}

void MainWindow::clearQtChatWidgetList()
{
    ui->chatList->clear();
}

void MainWindow::clearContactWidgets()
{
    std::map<megachat::MegaChatHandle, ContactListItemController *>::iterator it;
    for (it = mContactControllers.begin(); it != mContactControllers.end(); it++)
    {
        ContactListItemController *itemController = it->second;
        if(itemController)
        {
            itemController->addOrUpdateWidget(nullptr);
        }
    }
}

void MainWindow::clearChatWidgets()
{
    std::map<megachat::MegaChatHandle, ChatListItemController *>::iterator it;
    for (it = mChatControllers.begin(); it != mChatControllers.end(); it++)
    {
        ChatListItemController *itemController = it->second;
        if(itemController)
        {
            itemController->addOrUpdateWidget(nullptr);
        }
    }
}

void MainWindow::clearChatControllers()
{
    std::map<megachat::MegaChatHandle, ChatListItemController *>::iterator it;
    for (it = mChatControllers.begin(); it != mChatControllers.end(); it++)
    {
        ChatListItemController *itemController = it->second;
        delete itemController;
    }
    mChatControllers.clear();
}

void MainWindow::addOrUpdateContactControllersItems(MegaUserList *contactList)
{
    MegaUser *contact = NULL;

    for (int i = 0; i < contactList->size(); i++)
    {
        contact = contactList->get(i);
        ::mega::MegaHandle userHandle = contact->getHandle();
        if (userHandle != mMegaChatApi->getMyUserHandle())
        {
            ContactListItemController *itemController = getContactControllerById(contact->getHandle());
            if (!itemController)
            {
                itemController = new ContactListItemController(contact->copy());
                mContactControllers.insert(std::pair<megachat::MegaChatHandle, ContactListItemController *>(contact->getHandle(), itemController));
            }
            else
            {
                MegaUser *auxContact = contact->copy();
                itemController->addOrUpdateItem(auxContact);

                ContactItemWidget *widget = itemController->getWidget();
                if (widget)
                {
                    widget->updateToolTip(auxContact);
                }
            }
        }
    }
}

void MainWindow::reorderAppContactList()
{
    //Clean contacts Qt widgets container
    clearQtContactWidgetList();

    // Clean the ContacItemWidgets in ContactListItemController list
    clearContactWidgets();

    addQtContactWidgets();
}

void MainWindow::reorderAppChatList()
{
    mNeedReorder = false;

    //Clean chats Qt widgets container
    clearQtChatWidgetList();

    //Clean the ChatItemWidgets in ChatListItemController list
    clearChatWidgets();

    //Add archived chats
    if (mShowArchived)
    {
        addChatsBystatus(chatArchivedStatus);
    }

    //Add active/inactive chats
    addChatsBystatus(chatNotArchivedStatus);

    //Prepare tag to indicate chatrooms shown
    QString text;
    if (mShowArchived)
    {
        text.append(" Showing <all> chatrooms");
    }
    else
    {
        text.append(" Showing <active+inactive> chatrooms");
    }
    ui->mOnlineStatusDisplay->setText(text);
}

void MainWindow::addQtContactWidgets()
{
    ui->mContacsSeparator->setText(" Loading contacts");
    setNContacts(static_cast<int>(mContactControllers.size()));

    std::map<megachat::MegaChatHandle, ContactListItemController *>::iterator it;
    for (it = mContactControllers.begin(); it != mContactControllers.end(); it++)
    {
        MegaUser *contact = NULL;
        ContactListItemController *itemController = it->second;
        assert(itemController);
        contact = itemController->getItem();
        mega::MegaHandle userHandle = contact->getHandle();
        if (userHandle != mMegaChatApi->getMyUserHandle())
        {
            //Add Qt widget
            ContactItemWidget *widget = addQtContactWidget(contact);

            //Add or update widget in ContactListItemController
            itemController->addOrUpdateWidget(widget);
        }
    }

    if (mContactControllers.size() > 0)
    {
        ui->mContacsSeparator->setText("Showing <active> contacts");
    }
}

void MainWindow::addChatsBystatus(const int status)
{
    std::list<Chat> *chatList = getLocalChatListItemsByStatus(status);
    chatList->sort();
    for (Chat &chat : (*chatList))
    {
        const megachat::MegaChatListItem *auxItem = chat.chatItem;
        ChatListItemController *itemController = getChatControllerById(auxItem->getChatId());
        assert(itemController);

        //Add Qt widget
        ChatItemWidget *widget = addQtChatWidget(itemController->getItem());

        //Add or update widget in ChatListItemController
        itemController->addOrUpdateWidget(widget);
    }
    delete chatList;
}

bool MainWindow::eventFilter(QObject *, QEvent *event)
{
    if (this->mMegaChatApi->isSignalActivityRequired() && event->type() == QEvent::MouseButtonRelease)
    {
        this->mMegaChatApi->signalPresenceActivity();
    }
    return false;
}


void MainWindow::on_bSettings_clicked()
{
    QMenu menu(this);

    menu.setAttribute(Qt::WA_DeleteOnClose);

    // Chats
    QMenu *chatMenu = menu.addMenu("Chats");

    auto actPeerChat = chatMenu->addAction(tr("Create 1on1 chat (EKR on)"));
    connect(actPeerChat, &QAction::triggered, this, [=](){onAddChatRoom(false, false, false);});

    auto actGroupChat = chatMenu->addAction(tr("Create group chat (EKR on)"));
    connect(actGroupChat, &QAction::triggered, this, [=](){onAddChatRoom(true, false, false);});

    auto actPubChat = chatMenu->addAction(tr("Create public chat (EKR off)"));
    connect(actPubChat, &QAction::triggered, this, [=](){onAddChatRoom(true, true, false);});

    auto actMeetingRoom = chatMenu->addAction(tr("Create meeting room (EKR off)"));
    connect(actMeetingRoom, &QAction::triggered, this, [=](){onAddChatRoom(true, true, true);});

    auto actschedMeeting = chatMenu->addAction(tr("Create new chat and scheduled meeting (EKR off)"));
    connect(actschedMeeting, &QAction::triggered, this, [=](){onAddChatSchedMeeting();});
    auto actPreviewChat = chatMenu->addAction(tr("Preview chat-link"));
    connect(actPreviewChat,  &QAction::triggered, this, [this] {openChatPreview(true);});

    auto actCheckLink = chatMenu->addAction(tr("Check chat-link"));
    connect(actCheckLink,  &QAction::triggered, this, [this] {openChatPreview(false);});


    // Contacts
    QMenu *contactsMenu = menu.addMenu("Contacts");

    auto addAction = contactsMenu->addAction(tr("Add user to contacts"));
    connect(addAction, SIGNAL(triggered()), this, SLOT(onAddContact()));


    // Settings
    QMenu *settingsMenu = menu.addMenu("Settings");

    auto actSettings = settingsMenu->addAction("Open settings dialog");
    connect(actSettings, SIGNAL(triggered()), this, SLOT(onChatsSettingsClicked()));

    //TODO: prepare a new tab in SettingsDialog to configure all the presence options
    auto actWebRTC = settingsMenu->addAction(tr("Set A/V input devices (WebRTC)"));
    connect(actWebRTC, SIGNAL(triggered()), this, SLOT(onWebRTCsetting()));

    auto actChangeScreen = settingsMenu->addAction(tr("Select screen device"));
    connect(actChangeScreen, SIGNAL(triggered()), this, SLOT(onScreensSet()));

    auto actArchived = settingsMenu->addAction(tr("Show archived chats"));
    connect(actArchived, SIGNAL(triggered()), this, SLOT(onShowArchivedChats()));
    actArchived->setCheckable(true);
    actArchived->setChecked(mShowArchived);

    auto actTwoFactCheck = settingsMenu->addAction(tr("Enable/Disable 2FA"));
    connect(actTwoFactCheck, &QAction::triggered, this, [=](){onTwoFactorCheck();});
    actTwoFactCheck->setEnabled(mMegaApi->multiFactorAuthAvailable());


    // Notifications
    QMenu *notificationsMenu = menu.addMenu("Notifications");

    auto actChatCheckPushNotificationRestriction = notificationsMenu->addAction("Check PUSH notification setting");
    connect(actChatCheckPushNotificationRestriction, SIGNAL(triggered()), this, SLOT(onChatCheckPushNotificationRestrictionClicked()));

    auto actPushReceived = notificationsMenu->addAction(tr("Simulate PUSH received (iOS)"));
    connect(actPushReceived,  &QAction::triggered, this, [this] {onPushReceived(1);});

    auto actPushAndReceived = notificationsMenu->addAction(tr("Simulate PUSH received (Android)"));
    connect(actPushAndReceived,  &QAction::triggered, this, [this] {onPushReceived(0);});

    auto actImportMsgs = notificationsMenu->addAction(tr("Import messages from NSE cache"));
    connect(actImportMsgs, SIGNAL(triggered()), this, SLOT(onImportMessages()));

    // Other options
    QMenu *othersMenu = menu.addMenu("Others");

    auto actPrintMyInfo = othersMenu->addAction(tr("Print my info"));
    connect(actPrintMyInfo, SIGNAL(triggered()), this, SLOT(onPrintMyInfo()));

    auto actPrintUserAlerts = othersMenu->addAction(tr("Print scheduled meetings user alerts"));
    connect(actPrintUserAlerts, SIGNAL(triggered()), this, SLOT(onPrintUseralerts()));

    auto actRetryPendingConn = othersMenu->addAction(tr("Retry pending connections"));
    connect(actRetryPendingConn,  &QAction::triggered, this, [this] {onReconnect(false);});

    auto actForceReconnect = othersMenu->addAction(tr("Force reconnect"));
    connect(actForceReconnect,  &QAction::triggered, this, [this] {onReconnect(true);});

    auto actCatchUp = othersMenu->addAction(tr("Catch-Up with API"));
    connect(actCatchUp, SIGNAL(triggered()), this, SLOT(onCatchUp()));

    auto actSFUId = othersMenu->addAction(tr("Set SFU id"));
    connect(actSFUId, SIGNAL(triggered()), this, SLOT(onSetSFUId()));

    auto actSpeakReq = othersMenu->addAction(tr("Enable speak request feature"));
    connect(actSpeakReq, SIGNAL(triggered()), this, SLOT(onSpeakReqFeature()));

    auto actUseStaging = othersMenu->addAction("Use API staging");
    connect(actUseStaging, SIGNAL(toggled(bool)), this, SLOT(onUseApiStagingClicked(bool)));
    actUseStaging->setCheckable(true);
    actUseStaging->setChecked(mApp->isStagingEnabled());

    menu.addSeparator();

    auto actBackground = menu.addAction("Background status");
    connect(actBackground, SIGNAL(toggled(bool)), this, SLOT(onBackgroundStatusClicked(bool)));
    actBackground->setCheckable(true);
    actBackground->setChecked(mMegaChatApi->getBackgroundStatus());

    if (mIsEphemeraAccount)
    {
        menu.addSeparator();
        auto confirmAccount = menu.addAction("Confirm account");
        connect(confirmAccount, SIGNAL(triggered()), this, SLOT(onConfirmAccountClicked()));

    }

    if (mMegaChatApi->getInitState() == MegaChatApi::INIT_ANONYMOUS)
    {
        menu.addSeparator();
        auto joinAsGuest = menu.addAction("Join as guest");
        connect(joinAsGuest, SIGNAL(triggered()), this, SLOT(onJoinAsGuest()));
    }

    QPoint pos = ui->bSettings->pos();
    pos.setX(pos.x() + ui->bSettings->width());
    pos.setY(pos.y() + ui->bSettings->height());
    menu.exec(mapToGlobal(pos));
}

void MainWindow::onReconnect(bool disconnect)
{
    mMegaChatApi->retryPendingConnections(disconnect);
    mMegaApi->retryPendingConnections(disconnect);
}

void MainWindow::onPushReceived(unsigned int type)
{
    if (!type)
    {
        mMegaChatApi->pushReceived(false);
    }
    else
    {
        std::string aux = mApp->getText("Enter chatid (B64):");
        if (!aux.size())
            return;

        MegaChatHandle chatid = (aux.size() > 1)
                ? mMegaApi->base64ToUserHandle(aux.c_str())
                : MEGACHAT_INVALID_HANDLE;

        mMegaChatApi->pushReceived(false, chatid);
    }
}

void MainWindow::openChatPreview(bool create)
{
    std::string chatLink;
    QString qChatLink = QInputDialog::getText(this, tr("Load chat link"), tr("Enter a valid chatlink"));
    if (!qChatLink.isNull())
    {
        chatLink = qChatLink.toStdString();
        if (chatLink.empty())
        {
            QMessageBox::warning(this, tr("Load chat link"), tr("You can't enter an empty chatlink"));
            return;
        }
       create
        ?mMegaChatApi->openChatPreview(chatLink.c_str())
        :mMegaChatApi->checkChatLink(chatLink.c_str());
    }
}

void MainWindow::onPrintUseralerts()
{
    std::string text;
    std::unique_ptr<MegaUserAlertList> ual(mMegaApi->getUserAlerts());
    if (!ual || !ual->size()) { return; }

    for (int i = 0; i < ual->size(); ++i)
    {
       const MegaUserAlert* alert = ual->get(i);
       if (!alert ||
           (alert->getType() != MegaUserAlert::TYPE_SCHEDULEDMEETING_NEW
            && alert->getType() != MegaUserAlert::TYPE_SCHEDULEDMEETING_DELETED
            && alert->getType() != MegaUserAlert::TYPE_SCHEDULEDMEETING_UPDATED))
       {
            continue;
       }

       std::unique_ptr<char[]> chatid_64(mMegaApi->userHandleToBase64(alert->getNodeHandle()));
       std::unique_ptr<char[]> schedid_64(mMegaApi->userHandleToBase64(alert->getSchedId()));
       std::unique_ptr<char[]> parentSchedid_64(mMegaApi->userHandleToBase64(alert->getPcrHandle()));

       if (alert->getType() == MegaUserAlert::TYPE_SCHEDULEDMEETING_NEW)     { text.append("\n\n[Sm new]");     }
       if (alert->getType() == MegaUserAlert::TYPE_SCHEDULEDMEETING_UPDATED) { text.append("\n\n[Sm updated]"); }
       if (alert->getType() == MegaUserAlert::TYPE_SCHEDULEDMEETING_DELETED) { text.append("\n\n[Sm deleted]"); }
       text.append("\n\tUserAlert Id: ").append(std::to_string(alert->getId()));
       text.append("\n\tChatid: ").append(chatid_64.get());
       text.append("\n\tSchedid: ").append(chatid_64.get());
       text.append("\n\tParent: ").append(chatid_64.get());

       text.append("\n\tFields changed: {");
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_TITLE))         { text.append(" T "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_DESCRIPTION))   { text.append(" D "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_CANCELLED))     { text.append(" C "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_TIMEZONE))      { text.append(" TZ "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_STARTDATE))     { text.append(" S "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_ENDDATE))       { text.append(" E "); }
       if (alert->hasSchedMeetingChanged(MegaUserAlert::SM_CHANGE_TYPE_RULES))         { text.append(" R "); }
       text.append(" }");
    }

    QDialog dialog;
    QVBoxLayout layout(&dialog);
    QTextEdit textEdit;
    QPushButton closeBtn("Close");
    dialog.resize(600, 400);
    textEdit.setPlainText(text.c_str());
    textEdit.setReadOnly(true);
    layout.addWidget(&textEdit);
    layout.addWidget(&closeBtn);
    QObject::connect(&closeBtn, &QPushButton::clicked, &dialog, &QDialog::close);
    dialog.exec();
}

void MainWindow::onPrintMyInfo()
{
    QMessageBox msg;
    msg.setIcon(QMessageBox::Information);
    msg.setText(this->ui->bOnlineStatus->toolTip());
    msg.exec();
}

void MainWindow::updateToolTipMyInfo()
{
    QString text = NULL;
    megachat::MegaChatHandle myHandle = mMegaChatApi->getMyUserHandle();
    char *myMail = mMegaChatApi->getMyEmail();
    std::string myHandleBin = std::to_string(myHandle);
    const char *myHandle_64 = mMegaApi->userHandleToBase64(myHandle);
    text.append("\nMy email: ");
    text.append(myMail);
    text.append("\nMy User handle Bin: ");
    text.append(myHandleBin.c_str());
    text.append("\nMy User handle B64: ");
    text.append(QString::fromStdString(myHandle_64));
    ui->bOnlineStatus->setToolTip(text);
    delete [] myHandle_64;
    delete [] myMail;
}

void MainWindow::onWebRTCsetting()
{
    #ifndef KARERE_DISABLE_WEBRTC
    createSettingsMenu();
    #endif
}

void MainWindow::createSettingsMenu()
{
    ChatSettingsDialog *chatSettings = new ChatSettingsDialog(this);
    chatSettings->exec();
    chatSettings->deleteLater();
}

void MainWindow::on_bOnlineStatus_clicked()
{
    onlineStatus = new QMenu(this);
    auto actOnline = onlineStatus->addAction("Online");
    actOnline->setData(QVariant(MegaChatApi::STATUS_ONLINE));
    connect(actOnline, SIGNAL(triggered()), this, SLOT(setOnlineStatus()));

    auto actAway = onlineStatus->addAction("Away");
    actAway->setData(QVariant(MegaChatApi::STATUS_AWAY));
    connect(actAway, SIGNAL(triggered()), this, SLOT(setOnlineStatus()));

    auto actDnd = onlineStatus->addAction("Busy");
    actDnd->setData(QVariant(MegaChatApi::STATUS_BUSY));
    connect(actDnd, SIGNAL(triggered()), this, SLOT(setOnlineStatus()));

    auto actOffline = onlineStatus->addAction("Offline");
    actOffline->setData(QVariant(MegaChatApi::STATUS_OFFLINE));
    connect(actOffline, SIGNAL(triggered()), this, SLOT(setOnlineStatus()));

    QPoint pos = ui->bOnlineStatus->pos();
    pos.setX(pos.x() + ui->bOnlineStatus->width());
    pos.setY(pos.y() + ui->bOnlineStatus->height());

    onlineStatus->setStyleSheet("QMenu {"
        "background-color: qlineargradient("
        "spread:pad, x1:0, y1:0, x2:0, y2:1,"
            "stop:0 rgba(120,120,120,200),"
            "stop:1 rgba(180,180,180,200));"
        "}"
        "QMenu::item:!selected{"
            "color: white;"
        "}"
        "QMenu::item:selected{"
            "background-color: qlineargradient("
            "spread:pad, x1:0, y1:0, x2:0, y2:1,"
            "stop:0 rgba(120,120,120,200),"
            "stop:1 rgba(180,180,180,200));"
        "}");
    onlineStatus->exec(mapToGlobal(pos));
    onlineStatus->deleteLater();
}

void MainWindow::onShowArchivedChats()
{
    mShowArchived = !mShowArchived;
    reorderAppChatList();
}

ContactItemWidget *MainWindow::addQtContactWidget(MegaUser *user)
{
    //Create widget and add to interface
    int index = -(mArchivedChats + mNContacts);
    mNContacts += 1;
    ContactItemWidget *widget = new ContactItemWidget(ui->contactList, this, mMegaChatApi, mMegaApi, user);
    widget->updateToolTip(user);
    QListWidgetItem *item = new QListWidgetItem();
    widget->setWidgetItem(item);
    item->setSizeHint(QSize(item->sizeHint().height(), 28));
    ui->contactList->insertItem(index, item);
    ui->contactList->setItemWidget(item, widget);
    return widget;
}

ContactListItemController *MainWindow::addOrUpdateContactController(MegaUser *user)
{
    //If no controller exists we need to create
    std::map<mega::MegaHandle, ContactListItemController *>::iterator itContacts;
    itContacts = mContactControllers.find(user->getHandle());
    ContactListItemController *itemController;
    if (itContacts == mContactControllers.end())
    {
         itemController = new ContactListItemController(user);
    }
    else
    {
         //If controller exists we need to update item
         itemController = (ContactListItemController *) itContacts->second;
         itemController->addOrUpdateItem(user);
    }

    return itemController;
}

ChatListItemController *MainWindow::addOrUpdateChatControllerItem(MegaChatListItem *chatListItem)
{
    //If no controller exists we need to create
    std::map<mega::MegaHandle, ChatListItemController *>::iterator it;
    it = mChatControllers.find(chatListItem->getChatId());
    ChatListItemController *itemController;
    if (it == mChatControllers.end())
    {
         itemController = new ChatListItemController(this, chatListItem);
         mChatControllers.insert(std::pair<megachat::MegaChatHandle, ChatListItemController *>(chatListItem->getChatId(), itemController));
    }
    else
    {
         //If controller exists we need to update item
         itemController = (ChatListItemController *) it->second;
         itemController->addOrUpdateItem(chatListItem);
    }
    return itemController;
}

void MainWindow::closeChatPreview(megachat::MegaChatHandle chatId)
{
    ChatListItemController *itemController = nullptr;
    std::map<mega::MegaHandle, ChatListItemController *> ::iterator it;
    it = this->mChatControllers.find(chatId);
    if (it != mChatControllers.end())
    {
        itemController = it->second;
        megachat::MegaChatListItem *item = itemController->getItem();
        assert(item);
        if (!item->isPreview())
        {
            return;
        }

        mMegaChatApi->closeChatPreview(chatId);
    }
}

ChatItemWidget *MainWindow::addQtChatWidget(const MegaChatListItem *chatListItem)
{
    //Create widget and add to interface
    int index = 0;
    if (chatListItem->isArchived())
    {
        index = -(mArchivedChats);
        mArchivedChats += 1;
    }
    else if (!chatListItem->isActive())
    {
        index = -(mNContacts + mArchivedChats + mInactiveChats);
        mInactiveChats += 1;
    }
    else
    {
        index = -(mActiveChats + mInactiveChats + mArchivedChats+mNContacts);
        mActiveChats += 1;
    }

    ChatItemWidget *widget = new ChatItemWidget(this, chatListItem);
    widget->updateToolTip(chatListItem);
    QListWidgetItem *item = new QListWidgetItem();
    widget->setWidgetItem(item);
    item->setSizeHint(QSize(item->sizeHint().height(), 28));
    ui->chatList->insertItem(index, item);
    ui->chatList->setItemWidget(item, widget);
    return widget;
}

void MainWindow::onChatListItemUpdate(MegaChatApi *, MegaChatListItem *item)
{
    int oldPriv = megachat::MegaChatRoom::PRIV_UNKNOWN;
    ChatItemWidget *widget = nullptr;
    ChatListItemController *itemController = getChatControllerById(item->getChatId());

    //Get a copy of old privilege
    if (itemController)
    {
        if (itemController->getItem())
        {
           oldPriv = itemController->getItem()->getOwnPrivilege();
        }

        widget = itemController->getWidget();
    }
    itemController = addOrUpdateChatControllerItem(item->copy());

    if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_PREVIEW_CLOSED)
            || item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_DELETED))
    {
        ChatWindow * auxWindow = itemController->getChatWindow();
        if(auxWindow)
        {
            auxWindow->deleteLater();
        }

        mChatControllers.erase(itemController->getItemId());
        delete itemController;
        reorderAppChatList();
        return;
    }

    bool needreorder = needReorder(item, oldPriv);
    if ((!mAllowOrder && needreorder) || (!needreorder && !widget))
    {
        return;
    }

    // If we don't need to reorder and chatItemwidget is rendered
    // we need to update the widget because non order actions requires
    // a live update of widget
    if (!needreorder)
    {
        //Last Message update
        if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_LAST_MSG))
        {
            widget->updateToolTip(item);
        }

        //Unread count update
        if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_UNREAD_COUNT))
        {
            widget->onUnreadCountChanged(item->getUnreadCount());
        }

        //Title update
        if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_TITLE))
        {
            widget->onTitleChanged(item->getTitle());
        }

        //Own priv update
        if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_OWN_PRIV))
        {
            widget->updateToolTip(item);
        }

        //Participants update
        if (item->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_PARTICIPANTS))
        {
            widget->updateToolTip(item);
        }

        if (item->hasChanged(megachat::MegaChatRoom::CHANGE_TYPE_UPDATE_PREVIEWERS))
        {
            widget->onPreviewersCountChanged(item->getNumPreviewers());
            ChatWindow *win = itemController->getChatWindow();
            if (win)
            {
                win->updatePreviewers(item->getNumPreviewers());
            }
        }
    }
    else
    {
        reorderAppChatList();
    }
}

bool MainWindow::needReorder(MegaChatListItem *newItem, int oldPriv)
{
    if(newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_CLOSED)
         || newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_LAST_TS)
         || newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_ARCHIVE)
         || newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_DELETED)
         || newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_UNREAD_COUNT)
         || newItem->hasChanged(megachat::MegaChatListItem::CHANGE_TYPE_CHAT_MODE)
         || (newItem->getOwnPrivilege() == megachat::MegaChatRoom::PRIV_RM)         
         || ((oldPriv == megachat::MegaChatRoom::PRIV_RM)
             &&(newItem->getOwnPrivilege() > megachat::MegaChatRoom::PRIV_RM)))
    {
        mNeedReorder = true;
    }

    return mNeedReorder;
}

void MainWindow::activeControls(bool active)
{
    if (active)
    {
        ui->bOnlineStatus->show();
        ui->mLogout->show();
    }
    else
    {        
        ui->bOnlineStatus->hide();
    }
}

void MainWindow::onAddChatRoom(bool isGroup, bool isPublic, bool isMeeting)
{
    std::unique_ptr<::mega::MegaUserList> list(mMegaApi->getContacts());
    ChatGroupDialog *chatDialog = new ChatGroupDialog(this, isGroup, isPublic, isMeeting, mMegaChatApi);
    chatDialog->createChatList(list.get());
    chatDialog->show();
}

void MainWindow::onAddChatSchedMeeting()
{
    // define rules and flags from hardcoded
    std::unique_ptr<::mega::MegaIntegerList> byWeekDay(::mega::MegaIntegerList::createInstance());
    byWeekDay->add(1);byWeekDay->add(3);byWeekDay->add(5);

    std::unique_ptr<MegaChatScheduledFlags> flags(MegaChatScheduledFlags::createInstance());
    flags->setSendEmails(true);

    std::unique_ptr<MegaChatScheduledRules> rules(MegaChatScheduledRules::createInstance(MegaChatScheduledRules::FREQ_DAILY,
                                                                                         MegaChatScheduledRules::INTERVAL_INVALID,
                                                                                         MEGACHAT_INVALID_TIMESTAMP,
                                                                                         byWeekDay.get(), nullptr, nullptr));


    std::string timezone = mApp->getText("Get TimeZone (i.e: Europe/Madrid)", false);
    MegaChatTimeStamp startDate = atoi(mApp->getText("Get StartDate (Unix timestamp)", false).c_str());
    MegaChatTimeStamp endDate = atoi(mApp->getText("Get EndDate (Unix timestamp)", false).c_str());
    std::string title = mApp->getText("Get title", false);
    std::string description = mApp->getText("Get description", false);

    MegaChatPeerList* peerList =  MegaChatPeerList::createInstance();
    mMegaChatApi->createChatroomAndSchedMeeting(peerList, true /*isMeeting*/, true /*publicChat*/,  title.c_str(), false /*speakRequest*/, false /*waitingRoom*/, true /*openInvite*/,
                                                timezone.c_str(), startDate, endDate, description.c_str(),
                                                flags.get(), rules.get(), nullptr);
}

char *MainWindow::askChatTitle()
{
    char *title = NULL;
    std::string auxTitle = QInputDialog::getText(this, tr("Set chat title"), tr("Leave blank for default title")).toStdString();
    if (!auxTitle.empty())
    {
        title = new char[auxTitle.size() + 1];
        strncpy(title, auxTitle.c_str(), auxTitle.size() + 1);
    }
    return title;
}

void MainWindow::onAddContact()
{
    QString email = QInputDialog::getText(this, tr("Add contact"), tr("Please enter the email of the user to add"));
    if (email.isNull())
        return;

    char *myEmail = mMegaApi->getMyEmail();
    QString qMyEmail = myEmail;
    delete [] myEmail;

    if (email == qMyEmail)
    {
        QMessageBox::critical(this, tr("Add contact"), tr("You can't add your own email as contact"));
        return;
    }
    std::string emailStd = email.toStdString();
    mMegaApi->inviteContact(emailStd.c_str(),tr("I'd like to add you to my contact list").toUtf8().data(), MegaContactRequest::INVITE_ACTION_ADD);
}

void MainWindow::setOnlineStatus()
{
    auto action = qobject_cast<QAction*>(QObject::sender());
    assert(action);
    bool ok;
    auto pres = action->data().toUInt(&ok);
    if (!ok || (pres == MegaChatApi::STATUS_INVALID))
    {
        return;
    }
    this->mMegaChatApi->setOnlineStatus(pres);
}

void MainWindow::onChatConnectionStateUpdate(MegaChatApi *, MegaChatHandle chatid, int newState)
{
    if (chatid == megachat::MEGACHAT_INVALID_HANDLE)
    {
        // When we are connected to all chats we have to reorder the chatlist
        // we skip all reorders until we receive this event to avoid app overload
        mAllowOrder = true;

        //Reorder chat list in QtApp
        reorderAppChatList();
        return;
    }

    ChatListItemController *itemController = getChatControllerById(chatid);
    if (itemController)
    {
       ChatItemWidget *widget = itemController->getWidget();
       if (widget)
       {
            widget->onlineIndicatorUpdate(newState);
       }
    }
}

void MainWindow::onChatInitStateUpdate(megachat::MegaChatApi *, int newState)
{
    if (newState == MegaChatApi::INIT_ERROR)
    {
        QMessageBox msgBox;
        msgBox.setText("Critical error in MEGAchat. The application will close now. If the problem persists, you can delete your cached sessions.");
        msgBox.setStandardButtons(QMessageBox::Ok);
        int ret = msgBox.exec();

        if (ret == QMessageBox::Ok)
        {
            deleteLater();
            return;
        }
    }

    if (newState == MegaChatApi::INIT_ONLINE_SESSION || newState == MegaChatApi::INIT_OFFLINE_SESSION)
    {
        if(!isVisible())
        {
            mApp->resetLoginDialog();
            show();
        }

        const char *myEmail = mMegaChatApi->getMyEmail();
        QString auxTitle(myEmail);
        delete [] myEmail;

        if (mApp->sid() && newState == MegaChatApi::INIT_OFFLINE_SESSION)
        {
            auxTitle.append(" [OFFLINE MODE]");
        }

        if (auxTitle.size())
        {
            setWindowTitle(auxTitle);
        }

        std::unique_ptr<MegaUserList> contactList(mMegaApi->getContacts());
        addOrUpdateContactControllersItems(contactList.get());
        reorderAppContactList();

        //Update chatListItems in chatControllers
        updateChatControllersItems();

        //Reorder chat list in QtApp
        reorderAppChatList();

        //Update my user info tooltip
        updateToolTipMyInfo();

        if (newState == MegaChatApi::INIT_ONLINE_SESSION)
        {
            //Fetch alias attr
            mMegaApi->getUserAttribute(::mega::MegaApi::USER_ATTR_ALIAS);
            if (mApp->getJoinAsGuest())
            {
                mMegaChatApi->openChatPreview(mApp->getChatLink().c_str());
            }
        }
    }
}

void MainWindow::onChatOnlineStatusUpdate(MegaChatApi *, MegaChatHandle userhandle, int status, bool inProgress)
{
    if (mMegaChatApi->getMyUserHandle() == userhandle)
    {
        if (status == megachat::MegaChatApi::STATUS_INVALID)
        {
            // If we don't receive our presence we'll skip all chats reorders
            // when we are connected to all chats this flag will be set true
            // and chatlist will be reordered
            mAllowOrder = false;
            status = 0;
        }

        ui->bOnlineStatus->setText(inProgress
            ? kOnlineSymbol_InProgress
            : kOnlineSymbol_Set);

        if (status == megachat::MegaChatApi::STATUS_INVALID)
            status = 0;

        if (status >= 0 && status < NINDCOLORS)
            ui->bOnlineStatus->setStyleSheet(kOnlineStatusBtnStyle.arg(gOnlineIndColors[status]));
    }
    else
    {
        std::map<mega::MegaHandle, ContactListItemController *>::iterator itContacts;
        itContacts = this->mContactControllers.find((mega::MegaHandle) userhandle);
        if (itContacts != mContactControllers.end())
        {
            ContactListItemController *itemController = itContacts->second;
            assert(!inProgress);

            ContactItemWidget *widget = itemController->getWidget();
            if (widget)
            {
                widget->updateOnlineIndicator(status);
            }
        }
    }
}

void MainWindow::onChatPresenceConfigUpdate(MegaChatApi *, MegaChatPresenceConfig *)
{
    if (mSettings)
    {
        mSettings->onPresenceConfigUpdate();
    }
}

void MainWindow::onChatPresenceLastGreen(MegaChatApi */*api*/, MegaChatHandle userhandle, int lastGreen)
{
    const char *firstname = mApp->getFirstname(userhandle, NULL);
    if (!firstname)
    {
        firstname = mMegaApi->userHandleToBase64(userhandle);
    }

    std::string str;
    str.append("User: ");
    str.append(firstname);
    str.append("\nLast time green: ");
    str.append(std::to_string(lastGreen));
    str.append(" minutes ago");

    QMessageBox *msgBox = new QMessageBox(this);
    msgBox->setIcon( QMessageBox::Information );
    msgBox->setAttribute(Qt::WA_DeleteOnClose);
    msgBox->setStandardButtons(QMessageBox::Ok);
    msgBox->setWindowTitle( tr("Last time green"));
    msgBox->setText(str.c_str());
    msgBox->setModal(false);
    msgBox->show();
    delete [] firstname;
}

void MainWindow::onDbError(MegaChatApi */*api*/, int /*error*/, const char *msg)
{
    std::string text(msg);
    mLogger->postLog(text.c_str());

    if (!mCriticalMsgBox)
    {
        text.append("\n\nApplication will be closed when you accept this dialog");
        mCriticalMsgBox.reset(new QMessageBox(this));
        mCriticalMsgBox->setIcon( QMessageBox::Critical );
        mCriticalMsgBox->setAttribute(Qt::WA_DeleteOnClose);
        mCriticalMsgBox->setStandardButtons(QMessageBox::Ok);
        mCriticalMsgBox->setWindowTitle( tr("Karere DB error"));
        mCriticalMsgBox->setText(text.c_str());
        mCriticalMsgBox->setModal(true);
        switch (mCriticalMsgBox->exec())
        {
            case QMessageBox::Ok:
            default:
            {
                mCriticalMsgBox->deleteLater();
                mApp->closeAllWindows();
            }
        }
    }
}

void MainWindow::setNContacts(int nContacts)
{
    this->mNContacts = nContacts;
}

void MainWindow::updateMessageFirstname(MegaChatHandle contactHandle, const char *firstname)
{
    std::map<megachat::MegaChatHandle, ChatListItemController *>::iterator it;
    for (it = mChatControllers.begin(); it != mChatControllers.end(); it++)
    {
        ChatListItemController *itemController = it->second;
        const MegaChatListItem *item = itemController->getItem();
        ChatItemWidget *widget = itemController->getWidget();

        if (item && widget && item->getLastMessageSender() == contactHandle)
        {
            widget->updateToolTip(item, firstname);
        }

        ChatWindow *chatWindow = itemController->getChatWindow();
        if (chatWindow)
        {
            chatWindow->updateMessageFirstname(contactHandle, firstname);
        }
    }
}

void MainWindow::updateChatControllersItems()
{
    //Clean chatController list
    clearChatControllers();

    //Add all active chat controllers
    MegaChatListItemList *chatList = mMegaChatApi->getActiveChatListItems();
    for (unsigned int i = 0; i < chatList->size(); i++)
    {
        addOrUpdateChatControllerItem(chatList->get(i)->copy());
    }
    delete chatList;

    //Add inactive chat controllers
    chatList = mMegaChatApi->getInactiveChatListItems();
    for (unsigned int i = 0; i < chatList->size(); i++)
    {
        addOrUpdateChatControllerItem(chatList->get(i)->copy());
    }
    delete chatList;

    //Add archived chat controllers
    chatList = mMegaChatApi->getArchivedChatListItems();
    for (unsigned int i = 0; i < chatList->size(); i++)
    {
        addOrUpdateChatControllerItem(chatList->get(i)->copy());
    }
    delete chatList;
}

ContactListItemController *MainWindow::getContactControllerById(MegaChatHandle userId)
{
    std::map<mega::MegaHandle, ContactListItemController *> ::iterator it;
    it = mContactControllers.find(userId);
    if (it != mContactControllers.end())
    {
        return it->second;
    }

    return nullptr;
}

ChatListItemController *MainWindow::getChatControllerById(MegaChatHandle chatId)
{
    std::map<mega::MegaHandle, ChatListItemController *> ::iterator it;
    it = mChatControllers.find(chatId);
    if (it != mChatControllers.end())
    {
        return it->second;
    }

    return nullptr;
}

std::list<Chat> *MainWindow::getLocalChatListItemsByStatus(int status)
{
    std::list<Chat> *chatList = new std::list<Chat>;
    std::map<megachat::MegaChatHandle, ChatListItemController *>::iterator it;

    for (it = mChatControllers.begin(); it != mChatControllers.end(); it++)
    {
        ChatListItemController *itemController = it->second;
        const megachat::MegaChatListItem *item = itemController->getItem();

        assert(item);
        switch (status)
        {
            case chatNotArchivedStatus:
                if (!item->isArchived())
                {
                    chatList->push_back(Chat(item));
                }
                break;

            case chatArchivedStatus:
                if (item->isArchived())
                {
                    chatList->push_back(Chat(item));
                }
                break;
        }
    }
    return chatList;
}


void MainWindow::updateContactTitle(MegaChatHandle contactHandle, const char *title)
{
    std::map<mega::MegaHandle, ContactListItemController *>::iterator itContacts;
    itContacts = mContactControllers.find(contactHandle);

    if (itContacts != mContactControllers.end())
    {
        ContactListItemController *itemController = itContacts->second;
        itemController->getWidget()->updateName(title);
    }
}

void MainWindow::on_mLogout_clicked()
{
    QMessageBox msgBox;
    msgBox.setText("Do you want to logout?");
    msgBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
    msgBox.setDefaultButton(QMessageBox::Save);
    int ret = msgBox.exec();
    if (ret == QMessageBox::Ok)
    {
        removeListeners();
        clearChatControllers();
        clearContactControllersMap();
        if (mMegaChatApi->getInitState() == MegaChatApi::INIT_ANONYMOUS)
        {
            emit onAnonymousLogout();
        }
        else
        {
#ifdef ENABLE_SYNC
            mMegaApi->logout(false, nullptr);
#else
            mMegaApi->logout();
#endif

        }
    }    
}

void MainWindow::onCatchUp()
{
    mMegaApi->catchup();
}

void MainWindow::onSpeakReqFeature()
{
#ifndef KARERE_DISABLE_WEBRTC
    bool enable = atoi(mApp->getText("Enable speak request feature? 1(enable) | 0(disable)").c_str());
    mMegaChatApi->enableSpeakRequestSupportForCalls(enable);
#endif
}

void MainWindow::onSetSFUId()
{
#ifndef KARERE_DISABLE_WEBRTC
    int sfuid = atoi(mApp->getText("Set SFU id").c_str());
    mMegaChatApi->setSFUid(sfuid);
#else
    mApp->noFeatureErr();
#endif
}

void MainWindow::onlastGreenVisibleClicked()
{
    MegaChatPresenceConfig *presenceConfig = mMegaChatApi->getPresenceConfig();
    if (presenceConfig)
    {
        mMegaChatApi->setLastGreenVisible(!presenceConfig->isLastGreenVisible());
    }
    delete presenceConfig;
}

void MainWindow::onChatsSettingsClicked()
{
    if (!mSettings)
    {
        mSettings = new SettingWindow(mApp);
    }
    mSettings->show();
}

void MainWindow::onChatCheckPushNotificationRestrictionClicked()
{
    QString text = QInputDialog::getText(this, tr("Check PUSH notification settings"), tr("Enter chatid (B64): "));

    if (text == "")
        return;

    MegaHandle chatid = mMegaApi->base64ToUserHandle(text.toStdString().c_str());
    ChatListItemController *controller = getChatControllerById(chatid);
    controller->onCheckPushNotificationRestrictionClicked();
}

void MainWindow::onScreensSet()
{
#ifndef KARERE_DISABLE_WEBRTC
    std::unique_ptr<MegaStringList> l(mMegaChatApi->getChatScreenDevices());
    if (!l)
    {
        return;
    }

    std::string devList;
    for (int i = 0; i < l->size(); ++i)
    {
        devList += std::to_string(i) + ") " + l->get(i) + "\n";
    }

    QString text = QInputDialog::getText(this,
                                         tr("Select screen device (Enter device name)"),
                                         tr(devList.c_str()));
    if (text == "")
    {
        return;
    }

    mMegaChatApi->setScreenInDevice(text.toStdString().c_str());
#endif
}

void MainWindow::onUseApiStagingClicked(bool enable)
{
    mApp->enableStaging(enable);
}

void MainWindow::onBackgroundStatusClicked(bool status)
{
    mMegaChatApi->setBackgroundStatus(status);
}

void MainWindow::onConfirmAccountClicked()
{
    if (!mConfirmAccount)
    {
        mConfirmAccount = new ConfirmAccount();
        connect(mConfirmAccount, SIGNAL(onConfirmAccount(const std::string&, const std::string&)), this, SLOT(onAccountConfirmation(const std::string&, const std::string&)));
        connect(mConfirmAccount, SIGNAL(onCancel()), this, SLOT(onCancelAccountConfirmation()));
    }

    mConfirmAccount->show();
    mConfirmAccount->setModal(true);
}

void MainWindow::onImportMessages()
{
    QString text = QInputDialog::getText(this, tr("Import messages from NSE"), tr("Enter the path of the NSE cache: "));
    if (text == "")
        return;

    mMegaChatApi->importMessages(text.toStdString().c_str());
}

void MainWindow::onAccountConfirmation(const std::string &email, const std::string &password)
{
    unique_ptr<char[]> name = unique_ptr<char[]>(mMegaChatApi->getMyFirstname());
    mMegaApi->sendSignupLink(email.c_str(), name.get(), password.c_str());
    mConfirmAccount->deleteLater();
    mConfirmAccount = nullptr;
}

void MainWindow::onCancelAccountConfirmation()
{
    mConfirmAccount->deleteLater();
    mConfirmAccount = nullptr;
}

void MainWindow::onJoinAsGuest()
{
    mApp->setJoinAsGuest(true);
    QString text = QInputDialog::getText(this, tr("Guest user name"), tr("Enter the guest user name: "));
    if (text == "")
    {
        return;
    }

    mApp->setGuestName(text.toStdString());
    mMegaChatApi->logout(); // upon onRequestFinish, it calls createEphemeralAccountPlusPlus()
}
